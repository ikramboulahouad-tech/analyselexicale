import java.util.Arrays;

public class analysesyntaxique {

    static String[] tokens;
    static int position = 0;
    static boolean erreur = false;
    static int nbErreurs = 0;

    static String courant() {
        if (position >= tokens.length) return "#";
        return tokens[position];
    }

    static void ts() {
        position++;
    }

    static void Z() {
        if (courant().equals("int") && position + 1 < tokens.length && tokens[position + 1].equals("main")) {
            MainFunction();
        } else {
            if (courant().equals("int") || courant().equals("float") || courant().equals("char")) {
                DECLS();
            }
            INSTS();
        }
        
        System.out.println("\n--- RÉSUMÉ ---");
        if (!erreur && courant().equals("#")) {
            System.out.println("✅ Chaine correcte - Aucune erreur detectee");
        } else {
            System.out.println("❌ Chaine incorrecte - " + nbErreurs + " erreur(s) detectee(s)");
        }
    }

    static void MainFunction() {
        Type();
        if (courant().equals("main")) {
            ts();
            if (courant().equals("(")) {
                ts();
                if (courant().equals(")")) {
                    ts();
                    Block();
                } else {
                    erreur("')' attendue après main(");
                    while (!courant().equals("{") && !courant().equals("#")) {
                        ts();
                    }
                    if (courant().equals("{")) {
                        Block();
                    }
                }
            } else {
                erreur("'(' attendue après main");
                recuperer();
            }
        }
    }

    static void DECLS() {
        while (courant().equals("int") || courant().equals("float") || courant().equals("char")) {
            DeclVar();
        }
    }

    static void DeclVar() {
        Type();
        Ident();
        if (courant().equals("=")) {
            ts();
            EXPR();
        }
        if (courant().equals(";")) {
            ts();
        } else {
            erreur("Point-virgule attendu après déclaration de '" + tokens[position-1] + "'");
            if (!courant().equals("}") && !courant().equals("#")) {
                if (!estDebutInstruction()) {
                    recuperer();
                }
            }
        }
    }

    static void Type() {
        if (courant().equals("int") || courant().equals("float") || courant().equals("char")) {
            ts();
        } else {
            erreur("Type attendu (int, float, char)");
            ts();
        }
    }

    static void WhileInstr() {
        if (courant().equals("while")) {
            ts();
            if (courant().equals("(")) {
                ts();
                // Appeler COND_LOGIQUE au lieu de COND pour gérer les conditions complexes
                COND_LOGIQUE();
                
                if (courant().equals(")")) {
                    ts();
                    
                    if (!courant().equals("{")) {
                        INST();
                    } else {
                        Block();
                    }
                } else {
                    erreur("Parenthèse fermante ')' attendue après condition while");
                    recuperer();
                }
            } else {
                erreur("Parenthèse ouvrante '(' attendue après 'while'");
                if (Character.isLetter(courant().charAt(0))) {
                    while (!courant().equals("{") && !courant().equals(";") && 
                           !courant().equals("}") && !courant().equals("#")) {
                        ts();
                    }
                    if (courant().equals("{")) {
                        Block();
                    }
                } else {
                    recuperer();
                }
            }
        } else {
            erreur("'while' attendu");
            ts();
        }
    }

    static void IfInstr() {
        if (courant().equals("if")) {
            ts();
            if (courant().equals("(")) {
                ts();
                COND_LOGIQUE();
                if (courant().equals(")")) {
                    ts();
                    Block();
                    if (courant().equals("else")) {
                        ts();
                        Block();
                    }
                } else {
                    erreur("')' attendue après condition if");
                    recuperer();
                }
            } else {
                erreur("'(' attendue après if");
                recuperer();
            }
        }
    }

    // Nouvelle fonction pour gérer les conditions logiques avec && et ||
    static void COND_LOGIQUE() {
        COND_ET();
        while (courant().equals("||")) {
            ts();
            COND_ET();
        }
    }

    static void COND_ET() {
        COND_SIMPLE();
        while (courant().equals("&&")) {
            ts();
            COND_SIMPLE();
        }
    }

    // Gestion des conditions simples (avec ou sans parenthèses)
    static void COND_SIMPLE() {
        if (courant().equals("(")) {
            ts();
            COND_LOGIQUE(); // Récursivité pour gérer les parenthèses imbriquées
            if (courant().equals(")")) {
                ts();
            } else {
                erreur("Parenthèse fermante ')' attendue dans condition");
            }
        } else {
            // Expression de comparaison: EXPR RELOP EXPR
            EXPR();
            if (Arrays.asList("<", ">", "<=", ">=", "==", "!=").contains(courant())) {
                RELOP();
                EXPR();
            }
            // Si pas d'opérateur de comparaison, c'est une expression booléenne simple (accepté en C)
        }
    }

    // Ancienne fonction COND gardée pour compatibilité mais non utilisée
    static void COND() { 
        if (Character.isLetter(courant().charAt(0)) || Character.isDigit(courant().charAt(0))) {
            EXPR();
            
            if (!Arrays.asList("<", ">", "<=", ">=", "==", "!=").contains(courant())) {
                erreur("Opérateur de comparaison manquant dans la condition");
                return;
            }
            
            RELOP();
            EXPR();
            CONDprime();
        } else {
            erreur("Expression attendue dans la condition");
            ts();
        }
    }

    static void CONDprime() {
        while (courant().equals("&&") || courant().equals("||")) {
            ts();
            COND_SIMPLE_OLD();
        }
    }

    static void COND_SIMPLE_OLD() { 
        EXPR(); 
        RELOP(); 
        EXPR(); 
    }

    static void RELOP() {
        if (Arrays.asList("<", ">", "<=", ">=", "==", "!=").contains(courant())) {
            ts();
        } else {
            erreur("Opérateur de comparaison attendu");
            ts();
        }
    }

    static void Block() {
        if (courant().equals("{")) {
            ts();
            INSTS();
            if (courant().equals("}")) {
                ts();
            } else {
                erreur("Accolade fermante '}' attendue");
            }
        } else {
            erreur("Accolade ouvrante '{' attendue");
            if (estDebutInstruction()) {
                INST();
            } else {
                recuperer();
            }
        }
    }

    static void INSTS() {
        while (!courant().equals("}") && !courant().equals("#")) {
            INST();
            if (position >= tokens.length) break;
        }
    }

    static void INST() {
        if (courant().equals("while")) {
            WhileInstr();
        } else if (courant().equals("if")) {
            IfInstr();
        } else if (courant().equals("break")) {
            ts();
            if (courant().equals(";")) {
                ts();
            } else {
                erreur("';' attendu après break");
                recuperer();
            }
        } else if (courant().equals("return")) {
            ts();
            if (!courant().equals(";")) {
                EXPR();
            }
            if (courant().equals(";")) {
                ts();
            } else {
                erreur("';' attendu après return");
                recuperer();
            }
        } else if (courant().equals("int") || courant().equals("float") || courant().equals("char")) {
            DeclVar();
        } else if (courant().equals("scanf")) {
            ScanfInstr();
        } else if (courant().equals("printf")) {
            PrintfInstr();
        } else if (Character.isLetter(courant().charAt(0))) {
            String ident = courant();
            ts();
            
            if (Arrays.asList("<", ">", "<=", ">=", "==", "!=").contains(courant())) {
                erreur("Structure de contrôle manquante : 'while' attendu avant la condition");
                while (!courant().equals("{") && !courant().equals(";") && 
                       !courant().equals("}") && !courant().equals("#")) {
                    ts();
                }
                if (courant().equals("{")) {
                    int braceCount = 1;
                    ts();
                    while (braceCount > 0 && !courant().equals("#")) {
                        if (courant().equals("{")) braceCount++;
                        else if (courant().equals("}")) braceCount--;
                        ts();
                    }
                }
                return;
            }
            
            if (courant().equals("=")) {
                ts();
                EXPR();
                if (courant().equals(";")) {
                    ts();
                } else {
                    erreur("Point-virgule attendu après affectation");
                    if (!estDebutInstruction() && !courant().equals("}") && !courant().equals("#")) {
                        recuperer();
                    }
                }
            } else if (courant().equals("+=") || courant().equals("-=") || courant().equals("*=") || courant().equals("/=")) {
                ts();
                EXPR();
                if (courant().equals(";")) {
                    ts();
                } else {
                    erreur("';' attendu après opération composée");
                    recuperer();
                }
            } else if (courant().equals("++") || courant().equals("--")) {
                ts();
                if (courant().equals(";")) {
                    ts();
                } else {
                    erreur("Point-virgule attendu après incrémentation");
                    if (!estDebutInstruction() && !courant().equals("}") && !courant().equals("#")) {
                        recuperer();
                    }
                }
            } else {
                erreur("Opération attendue après identificateur '" + ident + "'");
                recuperer();
            }
        } else if (courant().equals("--") || courant().equals("++")) {
            ts();
            Ident();
            if (courant().equals(";")) {
                ts();
            } else {
                erreur("Point-virgule attendu après incrémentation");
                if (!estDebutInstruction() && !courant().equals("}") && !courant().equals("#")) {
                    recuperer();
                }
            }
        } else if (courant().equals("}")) {
            return;
        } else {
            erreur("Instruction invalide");
            ts();
        }
    }

    static void EXPR() {
        TERM();
        while (courant().equals("+") || courant().equals("-")) {
            ts();
            TERM();
        }
    }

    static void TERM() {
        FACTOR();
        while (courant().equals("*") || courant().equals("/") || courant().equals("%")) {
            ts();
            FACTOR();
        }
    }

    static void FACTOR() {
        if (courant().equals("#")) {
            erreur("Expression incomplète");
            return;
        }
        
        if (Character.isLetter(courant().charAt(0))) {
            Ident();
            if (courant().equals("++") || courant().equals("--")) ts();
        } else if (Character.isDigit(courant().charAt(0))) {
            Nombre();
        } else if (courant().equals("(")) {
            ts();
            EXPR();
            if (courant().equals(")")) {
                ts();
            } else {
                erreur("Parenthèse fermante ')' attendue");
                recuperer();
            }
        } else if (courant().equals("++") || courant().equals("--")) {
            ts();
            Ident();
        } else {
            erreur("Facteur invalide");
            ts();
        }
    }

    static void Ident() {
        if (Character.isLetter(courant().charAt(0))) {
            ts();
        } else {
            erreur("Identificateur attendu");
            ts();
        }
    }

    static void Nombre() {
        if (Character.isDigit(courant().charAt(0))) {
            ts();
        } else {
            erreur("Nombre attendu");
            ts();
        }
    }

    static void erreur(String msg) {
        System.out.println("❌ Erreur : " + msg + " à '" + courant() + "'");
        erreur = true;
        nbErreurs++;
    }

    static boolean estDebutInstruction() {
        return courant().equals("while") || 
               courant().equals("if") ||
               courant().equals("break") ||
               courant().equals("return") ||
               courant().equals("int") || 
               courant().equals("float") || 
               courant().equals("char") ||
               courant().equals("scanf") ||
               courant().equals("printf") ||
               courant().equals("{") ||
               courant().equals("}") ||
               (courant().length() > 0 && Character.isLetter(courant().charAt(0)));
    }

    static void recuperer() {
        if (courant().equals(";") || courant().equals("}") || 
            courant().equals("{") || courant().equals("#")) {
            if (courant().equals(";")) ts();
            return;
        }
        
        while (!courant().equals(";") && 
               !courant().equals("}") && 
               !courant().equals("{") && 
               !courant().equals("#") &&
               !estDebutInstruction()) {
            ts();
            if (position >= tokens.length) break;
        }
        
        if (courant().equals(";")) {
            ts();
        }
    }

    static void ScanfInstr() {
        ts();
        if (courant().equals("(")) {
            ts();
            if (courant().startsWith("\"") && courant().endsWith("\"")) {
                String format = courant().substring(1, courant().length()-1);
                if (!format.equals("%d") && !format.equals("%f") && !format.equals("%c")) {
                    erreur("Format attendu (%d, %f, %c) dans scanf");
                }
                ts();
                if (courant().equals(",")) {
                    ts();
                    if (courant().equals("&")) {
                        ts();
                        Ident();
                    } else if (Character.isLetter(courant().charAt(0))) {
                        erreur("'&' attendu avant identificateur dans scanf");
                        Ident();
                    } else {
                        erreur("Identificateur attendu après ',' dans scanf");
                        while (!courant().equals(")") && !courant().equals(";") && !courant().equals("#")) {
                            ts();
                        }
                    }
                    
                    if (courant().equals(")")) {
                        ts();
                        if (courant().equals(";")) {
                            ts();
                        } else {
                            erreur("Point-virgule attendu après scanf");
                            if (!estDebutInstruction()) recuperer();
                        }
                    } else {
                        erreur("Parenthèse fermante ')' attendue après scanf");
                        if (!estDebutInstruction()) recuperer();
                    }
                } else {
                    erreur("Virgule attendue après le format dans scanf");
                    recuperer();
                }
            } else {
                erreur("Format attendu entre guillemets dans scanf");
                recuperer();
            }
        } else {
            erreur("Parenthèse ouvrante '(' attendue après scanf");
            recuperer();
        }
    }

    static void PrintfInstr() {
        ts();
        if (courant().equals("(")) {
            ts();
            if (courant().startsWith("\"") && courant().endsWith("\"")) {
                ts();
                
                while (courant().equals(",")) {
                    ts();
                    EXPR();
                }
                
                if (courant().equals(")")) {
                    ts();
                    if (courant().equals(";")) {
                        ts();
                    } else {
                        erreur("Point-virgule attendu après printf");
                        if (!estDebutInstruction()) recuperer();
                    }
                } else {
                    erreur("Parenthèse fermante ')' attendue après printf");
                    if (!estDebutInstruction()) recuperer();
                }
            } else {
                erreur("Chaîne attendue dans printf");
                recuperer();
            }
        } else {
            erreur("Parenthèse ouvrante '(' attendue après printf");
            recuperer();
        }
    }
}
