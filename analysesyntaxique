package projetcompilation;
import java.util.Arrays;

public class analysesyntaxique {

    static String[] tokens;
    static int position = 0;
    static boolean erreur = false;

    static String courant() {
        if (position >= tokens.length) return "#";
        return tokens[position];
    }

    static void ts() {
        position++;
    }

    static void Z() {
        if (courant().equals("int") || courant().equals("float") || courant().equals("char")) {
            DECLS();
        }
        INSTS();
        
        // Résumé final
       
        if (!erreur && courant().equals("#")) {
            System.out.println("✅ Chaine correcte - Aucune erreur detectee");
        } else {
            System.out.println("❌ Chaine incorrecte - Des erreurs ont ete detectees");
        }
      
    }

    static void DECLS() {
        while (courant().equals("int") || courant().equals("float") || courant().equals("char")) {
            DeclVar();
        }
    }

    static void DeclVar() {
        Type();
        Ident();
        if (courant().equals("=")) {
            ts();
            EXPR();
        }
        if (courant().equals(";")) {
            ts();
        } else {
            erreur("Point-virgule attendu après déclaration");
            // Ne pas s'arrêter, juste signaler l'erreur
            if (!courant().equals("}") && !courant().equals("#")) {
                // Continue sans consommer si c'est un début d'instruction valide
                if (!estDebutInstruction()) {
                    recuperer();
                }
            }
        }
    }

    static void Type() {
        if (courant().equals("int") || courant().equals("float") || courant().equals("char")) {
            ts();
        } else {
            erreur("Type attendu (int, float, char)");
            ts(); // ← AJOUT : consomme le token invalide
        }
    }

    static void WhileInstr() {
        if (courant().equals("while")) {
            ts();
            if (courant().equals("(")) {
                ts();
                COND();
                if (courant().equals(")")) {
                    ts();
                    Block();
                } else {
                    erreur("Parenthèse fermante ')' attendue");
                    recuperer(); // ← AJOUT
                }
            } else {
                erreur("Parenthèse ouvrante '(' attendue");
                recuperer(); // ← AJOUT
            }
        } else {
            erreur("'while' attendu");
            ts(); // ← AJOUT
        }
    }

    static void COND() { 
        COND_SIMPLE(); 
        CONDprime(); 
    }

    static void CONDprime() {
        while (courant().equals("&&") || courant().equals("||")) {
            ts();
            COND_SIMPLE();
        }
    }

    static void COND_SIMPLE() { 
        EXPR(); 
        RELOP(); 
        EXPR(); 
    }

    static void RELOP() {
        if (Arrays.asList("<", ">", "<=", ">=", "==", "!=").contains(courant())) {
            ts();
        } else {
            erreur("Opérateur de comparaison attendu");
            ts(); // ← AJOUT : consomme le token invalide
        }
    }

    static void Block() {
        if (courant().equals("{")) {
            ts();
            INSTS();
            if (courant().equals("}")) {
                ts();
            } else {
                erreur("Accolade fermante '}' attendue");
                recuperer(); // ← AJOUT
            }
        } else {
            erreur("Accolade ouvrante '{' attendue");
            recuperer(); // ← AJOUT
        }
    }

    static void INSTS() {
        while (!courant().equals("}") && !courant().equals("#")) {
            INST();
        }
    }

    static void INST() {
        if (courant().equals("while")) {
            WhileInstr();
        } else if (courant().equals("int") || courant().equals("float") || courant().equals("char")) {
            DeclVar();
        } else if (courant().equals("scanf")) {
            ScanfInstr();
        } else if (courant().equals("printf")) {
            PrintfInstr();
        } else if (Character.isLetter(courant().charAt(0))) {
            String ident = courant();
            ts();
            if (courant().equals("=")) {
                ts();
                EXPR();
                if (courant().equals(";")) {
                    ts();
                } else {
                    erreur("Point-virgule attendu après affectation");
                    // Continue sans bloquer
                    if (!estDebutInstruction() && !courant().equals("}") && !courant().equals("#")) {
                        recuperer();
                    }
                }
            } else if (courant().equals("++") || courant().equals("--")) {
                ts();
                if (courant().equals(";")) {
                    ts();
                } else {
                    erreur("Point-virgule attendu après incrémentation");
                    // Continue sans bloquer
                    if (!estDebutInstruction() && !courant().equals("}") && !courant().equals("#")) {
                        recuperer();
                    }
                }
            } else {
                erreur("Opération attendue après identificateur");
                recuperer();
            }
        } else if (courant().equals("--") || courant().equals("++")) {
            // Gestion de --c ou ++c seul
            ts();
            Ident();
            if (courant().equals(";")) {
                ts();
            } else {
                erreur("Point-virgule attendu après incrémentation");
                if (!estDebutInstruction() && !courant().equals("}") && !courant().equals("#")) {
                    recuperer();
                }
            }
        } else {
            erreur("Instruction invalide");
            ts(); // Consomme le token invalide pour éviter boucle infinie
        }
    }

    static void EXPR() {
        TERM();
        while (courant().equals("+") || courant().equals("-")) {
            ts();
            TERM();
        }
    }

    static void TERM() {
        FACTOR();
        while (courant().equals("*") || courant().equals("/")) {
            ts();
            FACTOR();
        }
    }

    static void FACTOR() {
        if (Character.isLetter(courant().charAt(0))) {
            Ident();
            if (courant().equals("++") || courant().equals("--")) ts();
        } else if (Character.isDigit(courant().charAt(0))) {
            Nombre();
        } else if (courant().equals("(")) {
            ts();
            EXPR();
            if (courant().equals(")")) {
                ts();
            } else {
                erreur("Parenthèse fermante ')' attendue");
                recuperer(); // ← AJOUT
            }
        } else if (courant().equals("++") || courant().equals("--")) {
            ts();
            Ident();
        } else {
            erreur("Facteur invalide");
            ts(); // ← AJOUT : consomme le token invalide
        }
    }

    static void Ident() {
        if (Character.isLetter(courant().charAt(0))) {
            ts();
        } else {
            erreur("Identificateur attendu");
            ts(); // ← AJOUT : consomme le token invalide
        }
    }

    static void Nombre() {
        if (Character.isDigit(courant().charAt(0))) {
            ts();
        } else {
            erreur("Nombre attendu");
            ts(); // ← AJOUT : consomme le token invalide
        }
    }

    static void erreur(String msg) {
        System.out.println("❌ Erreur : " + msg + " à '" + courant() + "'");
        erreur = true;
        // NE PAS sortir, continuer l'analyse
    }

    // Fonction pour vérifier si c'est un début d'instruction
    static boolean estDebutInstruction() {
        return courant().equals("while") || 
               courant().equals("int") || 
               courant().equals("float") || 
               courant().equals("char") ||
               courant().equals("scanf") ||
               courant().equals("printf") ||
               courant().equals("{") ||
               courant().equals("}") ||
               Character.isLetter(courant().charAt(0));
    }

    // ← NOUVELLE FONCTION : Récupération d'erreur améliorée
    static void recuperer() {
        // Si on est déjà sur un point de synchronisation, ne rien faire
        if (courant().equals(";") || courant().equals("}") || 
            courant().equals("{") || courant().equals("#")) {
            if (courant().equals(";")) ts();
            return;
        }
        
        // Sinon, avance jusqu'au prochain point de synchronisation
        while (!courant().equals(";") && 
               !courant().equals("}") && 
               !courant().equals("{") && 
               !courant().equals("#") &&
               !estDebutInstruction()) {
            ts();
        }
        
        // Consomme le point-virgule si trouvé
        if (courant().equals(";")) {
            ts();
        }
    }

    // --- Gestion scanf et printf ---
    static void ScanfInstr() {
        ts();
        if (courant().equals("(")) {
            ts();
            if (courant().startsWith("\"") && courant().endsWith("\"")) {
                String format = courant().substring(1, courant().length()-1);
                if (!format.equals("%d") && !format.equals("%f") && !format.equals("%c")) {
                    erreur("Format attendu (%d, %f, %c) dans scanf");
                }
                ts();
                if (courant().equals(",")) {
                    ts();
                    if (courant().equals("&")) {
                        ts();
                        Ident();
                        if (courant().equals(")")) {
                            ts();
                            if (courant().equals(";")) {
                                ts();
                            } else {
                                erreur("Point-virgule attendu après scanf");
                                recuperer(); // ← AJOUT
                            }
                        } else {
                            erreur("Parenthèse fermante ')' attendue après scanf");
                            recuperer(); // ← AJOUT
                        }
                    } else {
                        erreur("'&' attendu avant identificateur dans scanf");
                        recuperer(); // ← AJOUT
                    }
                } else {
                    erreur("Virgule attendue après le format dans scanf");
                    recuperer(); // ← AJOUT
                }
            } else {
                erreur("Format attendu entre guillemets dans scanf");
                recuperer(); // ← AJOUT
            }
        } else {
            erreur("Parenthèse ouvrante '(' attendue après scanf");
            recuperer(); // ← AJOUT
        }
    }

    static void PrintfInstr() {
        ts();
        if (courant().equals("(")) {
            ts();
            if (courant().startsWith("\"") && courant().endsWith("\"")) {
                ts();
                if (courant().equals(",")) {
                    ts();
                    EXPR();
                }
                if (courant().equals(")")) {
                    ts();
                    if (courant().equals(";")) {
                        ts();
                    } else {
                        erreur("Point-virgule attendu après printf");
                        recuperer(); // ← AJOUT
                    }
                } else {
                    erreur("Parenthèse fermante ')' attendue après printf");
                    recuperer(); // ← AJOUT
                }
            } else {
                erreur("Chaîne attendue dans printf");
                recuperer(); // ← AJOUT
            }
        } else {
            erreur("Parenthèse ouvrante '(' attendue après printf");
            recuperer(); // ← AJOUT
        }
    }
}
