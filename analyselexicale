import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class analyselexicale {

    enum TokenType { IDENT, KEYWORD, NUMBER, OP, DELIM, STRING, PREPROCESSOR, ERROR }

    static class Token {
        TokenType type;
        String lexeme;
        boolean isCustomKeyword;

        public Token(TokenType t, String l, boolean custom) {
            type = t;
            lexeme = l;
            isCustomKeyword = custom;
        }

        private String typeLabel() {
            switch (type) {
                case IDENT: return "Identificateur";
                case KEYWORD: return isCustomKeyword ? "Mot-clé personnalisé" : "Mot-clé";
                case NUMBER: return "Nombre";
                case OP: return "Opérateur";
                case DELIM: return "Délimiteur";
                case STRING: return "Chaîne";
                case PREPROCESSOR: return "Directive préprocesseur";
                case ERROR: return "Erreur lexicale";
                default: return "Inconnu";
            }
        }

        @Override
        public String toString() {
            return lexeme + ":" + typeLabel();
        }
    }

    static final int FIN = -1;
    static final int L = 0, UNDERSCORE = 1, D = 2, SLASH = 3, PLUS = 4, MINUS = 5,
            STAR = 6, PERCENT = 7, LT = 8, GT = 9, EQ = 10, EXCL = 11,
            AMP = 12, PIPE = 13, DEL = 14, WS = 15, DOT = 16, NL = 17, AUTRE = 18;

    static int[][] M = {
            {  2,  2,  3,  4,  5,  6,  7,  7,  8,  9, 10, 11, 12, 13, 14,  1, 15,  1, 16 },
            {  2,  2,  2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
            { -1, -1,  3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1 },
            { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
            { -1, -1, -1, -1,  7, -1, -1, -1, -1, -1,  7, -1, -1, -1, -1, -1, -1, -1, -1 },
            { -1, -1, -1, -1, -1,  7, -1, -1, -1, -1,  7, -1, -1, -1, -1, -1, -1, -1, -1 },
            { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
            { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  7, -1, -1, -1, -1, -1, -1, -1, -1 },
            { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  7, -1, -1, -1, -1, -1, -1, -1, -1 },
            { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  7, -1, -1, -1, -1, -1, -1, -1, -1 },
            { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  7, -1, -1, -1, -1, -1, -1, -1, -1 },
            { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  7, -1, -1, -1, -1, -1, -1 },
            { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  7, -1, -1, -1, -1, -1 },
            { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
            { -1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
            { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
            { -1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
    };

    static int col(char c) {
        if (Character.isLetter(c)) return L;
        if (c == '_') return UNDERSCORE;
        if (Character.isDigit(c)) return D;
        if (c == '/') return SLASH;
        if (c == '+') return PLUS;
        if (c == '-') return MINUS;
        if (c == '*') return STAR;
        if (c == '%') return PERCENT;
        if (c == '<') return LT;
        if (c == '>') return GT;
        if (c == '=') return EQ;
        if (c == '!') return EXCL;
        if (c == '&') return AMP;
        if (c == '|') return PIPE;
        if (",;(){}".indexOf(c) != -1) return DEL;
        if (c == ' ' || c == '\t') return WS;
        if (c == '.') return DOT;
        if (c == '\n') return NL;
        return AUTRE;
    }

    static String motCle(String lexeme) {
        String l = lexeme.trim();
        String lower = l.toLowerCase();
        if (lower.equals("boulahouad")) return "CUSTOM_NOM";
        if (lower.equals("ikram")) return "CUSTOM_PRENOM";
        switch (l) {
            case "int": case "float": case "char": case "double": case "void":
                return "TYPE";
            case "if": case "else": case "while": case "for": case "do":
            case "return": case "break": case "continue":
            case "printf": case "scanf": case "main":
                return "KEYWORD";
            default: return "IDENTIFIANT";
        }
    }

    public static List<Token> scan(String input) {
        List<Token> tokens = new ArrayList<>();
        int i = 0;

        while (i < input.length()) {
            char c = input.charAt(i);

            // #include ou #define
            if (c == '#') {
                StringBuilder prep = new StringBuilder();
                prep.append(c);
                i++;
                while (i < input.length() && input.charAt(i) != '\n') {
                    prep.append(input.charAt(i));
                    i++;
                }
                tokens.add(new Token(TokenType.PREPROCESSOR, prep.toString().trim(), false));
                continue;
            }

            // Chaînes "..."
            if (c == '"') {
                StringBuilder str = new StringBuilder();
                str.append(c);
                i++;
                while (i < input.length() && input.charAt(i) != '"') {
                    if (input.charAt(i) == '\\' && i + 1 < input.length()) {
                        str.append(input.charAt(i));
                        i++;
                    }
                    str.append(input.charAt(i));
                    i++;
                }
                if (i < input.length()) {
                    str.append('"');
                    i++;
                }
                tokens.add(new Token(TokenType.STRING, str.toString(), false));
                continue;
            }

            // Caractères '<' et '>' dans #include
            if ((c == '<' || c == '>') && !tokens.isEmpty() && 
                tokens.get(tokens.size()-1).type == TokenType.PREPROCESSOR) {
                StringBuilder header = new StringBuilder();
                header.append(c);
                i++;
                while (i < input.length() && input.charAt(i) != '>' && input.charAt(i) != '\n') {
                    header.append(input.charAt(i));
                    i++;
                }
                if (i < input.length() && input.charAt(i) == '>') {
                    header.append('>');
                    i++;
                }
                tokens.add(new Token(TokenType.STRING, header.toString(), false));
                continue;
            }

            // Automate classique
            int etat = 1;
            StringBuilder lex = new StringBuilder();

            while (i < input.length() && etat != FIN) {
                c = input.charAt(i);
                int col_index = col(c);
                int newState = M[etat - 1][col_index];

                if (newState == FIN) break;

                if (col_index != WS && col_index != NL) {
                    lex.append(c);
                }

                etat = newState;
                i++;
            }

            String lexeme = lex.toString().trim();
            if (lexeme.isEmpty()) {
                if (i < input.length()) i++;
                continue;
            }

            TokenType type;
            switch (etat) {
                case 2: {
                    String mc = motCle(lexeme);
                    if (mc.startsWith("CUSTOM")) type = TokenType.KEYWORD;
                    else if (!mc.equals("IDENTIFIANT")) type = TokenType.KEYWORD;
                    else type = TokenType.IDENT;
                    tokens.add(new Token(type, lexeme, mc.startsWith("CUSTOM")));
                    break;
                }
                case 3: case 17:
                    type = TokenType.NUMBER;
                    tokens.add(new Token(type, lexeme, false));
                    break;
                case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 13:
                    type = TokenType.OP;
                    tokens.add(new Token(type, lexeme, false));
                    break;
                case 14:
                    type = TokenType.DELIM;
                    tokens.add(new Token(type, lexeme, false));
                    break;
                default:
                    type = TokenType.ERROR;
                    tokens.add(new Token(type, lexeme, false));
                    break;
            }
        }

        return tokens;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        StringBuilder codeComplet = new StringBuilder();

        System.out.println("=== COMPILATEUR C - PROGRAMME COMPLET ===");
        System.out.println("Entrez le code (tapez 'FIN' pour terminer) :\n");

        while (true) {
            String ligne = sc.nextLine();
            if (ligne.equals("FIN")) break;
            codeComplet.append(ligne).append("\n");
        }

        // ANALYSE LEXICALE
        List<Token> tokensList = scan(codeComplet.toString());
        System.out.println("\n=== LEXÈMES RECONNUS ===");
        for (Token tok : tokensList) {
            System.out.println(tok);
        }

        // ANALYSE SYNTAXIQUE
        System.out.println("\n=== ANALYSE SYNTAXIQUE ===");
        
        // Conversion des tokens pour l'analyseur syntaxique
        List<String> lexemesList = new ArrayList<>();
        for (Token tok : tokensList) {
            // On ignore les directives préprocesseur pour l'analyse syntaxique
            if (tok.type != TokenType.PREPROCESSOR) {
                lexemesList.add(tok.lexeme);
            }
        }
        
        // Initialisation de l'analyseur syntaxique
        analysesyntaxique.tokens = lexemesList.toArray(new String[0]);
        analysesyntaxique.position = 0;
        analysesyntaxique.erreur = false;
        
        // Lancement de l'analyse
        analysesyntaxique.Z();

        sc.close();
    }
}
